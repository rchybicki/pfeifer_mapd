// Code generated by capnpc-go. DO NOT EDIT.

package main

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
)

type Way capnp.Struct

// Way_TypeID is the unique identifier for the type Way.
const Way_TypeID = 0xa4b9c59286b69600

func NewWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 104, PointerCount: 4})
	return Way(st), err
}

func NewRootWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 104, PointerCount: 4})
	return Way(st), err
}

func ReadRootWay(msg *capnp.Message) (Way, error) {
	root, err := msg.Root()
	return Way(root.Struct()), err
}

func (s Way) String() string {
	str, _ := text.Marshal(0xa4b9c59286b69600, capnp.Struct(s))
	return str
}

func (s Way) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Way) DecodeFromPtr(p capnp.Ptr) Way {
	return Way(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Way) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Way) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Way) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Way) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Way) Id() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Way) SetId(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Way) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Way) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Way) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Way) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Way) Ref() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Way) HasRef() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Way) RefBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Way) SetRef(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Way) MaxSpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Way) SetMaxSpeed(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Way) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Way) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Way) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Way) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Way) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Way) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Way) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(40))
}

func (s Way) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(40, math.Float64bits(v))
}

func (s Way) Nodes() (Coordinates_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Coordinates_List(p.List()), err
}

func (s Way) HasNodes() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Way) SetNodes(v Coordinates_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewNodes sets the nodes field to a newly
// allocated Coordinates_List, preferring placement in s's segment.
func (s Way) NewNodes(n int32) (Coordinates_List, error) {
	l, err := NewCoordinates_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Coordinates_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Way) Lanes() uint8 {
	return capnp.Struct(s).Uint8(48)
}

func (s Way) SetLanes(v uint8) {
	capnp.Struct(s).SetUint8(48, v)
}

func (s Way) AdvisorySpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(56))
}

func (s Way) SetAdvisorySpeed(v float64) {
	capnp.Struct(s).SetUint64(56, math.Float64bits(v))
}

func (s Way) Hazard() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Way) HasHazard() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Way) HazardBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Way) SetHazard(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Way) OneWay() bool {
	return capnp.Struct(s).Bit(392)
}

func (s Way) SetOneWay(v bool) {
	capnp.Struct(s).SetBit(392, v)
}

func (s Way) MaxSpeedPractical() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(64))
}

func (s Way) SetMaxSpeedPractical(v float64) {
	capnp.Struct(s).SetUint64(64, math.Float64bits(v))
}

func (s Way) MaxSpeedPracticalForward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(72))
}

func (s Way) SetMaxSpeedPracticalForward(v float64) {
	capnp.Struct(s).SetUint64(72, math.Float64bits(v))
}

func (s Way) MaxSpeedPracticalBackward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(80))
}

func (s Way) SetMaxSpeedPracticalBackward(v float64) {
	capnp.Struct(s).SetUint64(80, math.Float64bits(v))
}

func (s Way) MaxSpeedForward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(88))
}

func (s Way) SetMaxSpeedForward(v float64) {
	capnp.Struct(s).SetUint64(88, math.Float64bits(v))
}

func (s Way) MaxSpeedBackward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(96))
}

func (s Way) SetMaxSpeedBackward(v float64) {
	capnp.Struct(s).SetUint64(96, math.Float64bits(v))
}

// Way_List is a list of Way.
type Way_List = capnp.StructList[Way]

// NewWay creates a new list of Way.
func NewWay_List(s *capnp.Segment, sz int32) (Way_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 104, PointerCount: 4}, sz)
	return capnp.StructList[Way](l), err
}

// Way_Future is a wrapper for a Way promised by a client call.
type Way_Future struct{ *capnp.Future }

func (f Way_Future) Struct() (Way, error) {
	p, err := f.Future.Ptr()
	return Way(p.Struct()), err
}

type Coordinates capnp.Struct

// Coordinates_TypeID is the unique identifier for the type Coordinates.
const Coordinates_TypeID = 0x922b57c60c6a46d1

func NewCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func NewRootCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func ReadRootCoordinates(msg *capnp.Message) (Coordinates, error) {
	root, err := msg.Root()
	return Coordinates(root.Struct()), err
}

func (s Coordinates) String() string {
	str, _ := text.Marshal(0x922b57c60c6a46d1, capnp.Struct(s))
	return str
}

func (s Coordinates) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Coordinates) DecodeFromPtr(p capnp.Ptr) Coordinates {
	return Coordinates(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Coordinates) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Coordinates) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Coordinates) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Coordinates) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Coordinates) Latitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Coordinates) SetLatitude(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Coordinates) Longitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Coordinates) SetLongitude(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Coordinates_List is a list of Coordinates.
type Coordinates_List = capnp.StructList[Coordinates]

// NewCoordinates creates a new list of Coordinates.
func NewCoordinates_List(s *capnp.Segment, sz int32) (Coordinates_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Coordinates](l), err
}

// Coordinates_Future is a wrapper for a Coordinates promised by a client call.
type Coordinates_Future struct{ *capnp.Future }

func (f Coordinates_Future) Struct() (Coordinates, error) {
	p, err := f.Future.Ptr()
	return Coordinates(p.Struct()), err
}

type Offline capnp.Struct

// Offline_TypeID is the unique identifier for the type Offline.
const Offline_TypeID = 0xcb5ff253617678e0

func NewOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func NewRootOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func ReadRootOffline(msg *capnp.Message) (Offline, error) {
	root, err := msg.Root()
	return Offline(root.Struct()), err
}

func (s Offline) String() string {
	str, _ := text.Marshal(0xcb5ff253617678e0, capnp.Struct(s))
	return str
}

func (s Offline) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Offline) DecodeFromPtr(p capnp.Ptr) Offline {
	return Offline(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Offline) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Offline) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Offline) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Offline) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Offline) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Offline) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Offline) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Offline) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Offline) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Offline) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Offline) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Offline) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Offline) Ways() (Way_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Way_List(p.List()), err
}

func (s Offline) HasWays() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Offline) SetWays(v Way_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewWays sets the ways field to a newly
// allocated Way_List, preferring placement in s's segment.
func (s Offline) NewWays(n int32) (Way_List, error) {
	l, err := NewWay_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Way_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Offline) Overlap() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Offline) SetOverlap(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

// Offline_List is a list of Offline.
type Offline_List = capnp.StructList[Offline]

// NewOffline creates a new list of Offline.
func NewOffline_List(s *capnp.Segment, sz int32) (Offline_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1}, sz)
	return capnp.StructList[Offline](l), err
}

// Offline_Future is a wrapper for a Offline promised by a client call.
type Offline_Future struct{ *capnp.Future }

func (f Offline_Future) Struct() (Offline, error) {
	p, err := f.Future.Ptr()
	return Offline(p.Struct()), err
}

const schema_da3a0d9284ca402f = "x\xda\xa4\xd4Oh\x1cU\x1c\x07\xf0\xef\xf7\xf7f6" +
	"\x9b\xec\x9fdxs\x10\xa9D\xa5BZ\xad&Z\xa1" +
	"\x04\xa1\xb5J)E0/#\xc4\x9b>2\x13]\xdd" +
	"\xcc\x84\xc9\x9al\xbc\x08\"\xa2\x82\x07\x17\x11\x05\x85\x0a" +
	"\x11\x14<y\x10=\x08\x1e\xd4C=\xd9\xa3'\x0f\x1e" +
	"\x14,Xi\xb1\x07u\xe57\xed&[s\xf46\xef" +
	"\xf3\xfb\xbd?\xec{\xdf\xbd]N\x05\x0b\xadB \xee" +
	"PX\x1b\xfep\xe6\xb9\xe6w+w\x0f\xe0\xda\x94\xe1" +
	"}\xa7.\xbc2h-\xfe\x88`\x02\xb0\xb7\xf1\xa2=" +
	"B\xfd\xba\x8b\xdb\xe0?\xef|\xfe\xea\xe0\xdb/w]" +
	"\x9b\xad\xfd\xce\xb0j}\x9d\x03\xfb\x96\xb6>\xf0&\xff" +
	"4\xe0\xf0\xa7\xfe\x96O\xfex\xea{]7\x1c\xeb\xae" +
	"\x96\xbb\x14~f\xaf\x86\xda}9\\!\x8e\x0d\x8b\xb5" +
	"\xb5n'\xcf\xee\x95U\xbf\x91o,>R\x14e\xda" +
	"\xc9}/\xe3\xe6\x12\xe9\xea&\x00\x02\x02\xd1\x91s\x80" +
	"\x9b3t\xc7\x85\x11\x19Sqa\x19p\xf3\x86\xee!" +
	"\xe1\xb0\xeb{\x9d\xde\x0bi\x06\x80\x0d\x08\x1b\xe0\xb0[" +
	"\xe4\xcf(\x82\xd9\x9e\x8d\xb6\xe4\xf5-W<wt\xab" +
	"\xb3\xa3\xad\xec\xaf\xbc\x15H~\xa6a\xf2;\x8576" +
	"\xb3\x97x\x14H~Q\xbeBa$\x8c)\x80\xbd\xcc" +
	";\x81\xe47\xf5k\xea\x861\x0d`\xaf\xf2\x1c\x90\\" +
	"\xa1\xe1\xb2\x08\xa3@b\x06\x80\xfd\x9b\x8b@rM\xdb" +
	"\x03\xf5\xd0\xc4\x0c\x01KQ\xffK\xbd\xae^\x0bb\xd6" +
	"\x00\x1b\xaa/\x8ba\xd2T\x9e\x08\xe3\xea\x97\x9c\xac\xda" +
	"\x03\xf5\x19\xf5\xba\xc4\xac\x03\xb6%\xf7\x03I]\xfd\xb0" +
	"\xfa\xe4|\xccI\xc0\xdeQ\xf9!\xf59\xf5\xa9\x89\x98" +
	"Sz\xc1R\x02\xc9a\xf5y\xf5\x86\x89\xd9\x00\xec\xb1" +
	"j\xfd9\xf5\xe3\"\\h\xbe\xc6\x98M\xc0.T\x85" +
	"{\xb4pB'\xb4\xea1[\x80}P\x06@rB" +
	"\xfdQ\xf5\xf6d\xcc6`\x1f\x96\x0b@rV\xfd\x09" +
	"\xf5\xe9\xa9\x98\xd3\x80ur\x11H\x9eTO\xd5g\x1a" +
	"1g\x00\xeb\xe5e yZ\xbd\xab\x1e5cF\x80" +
	"\xed\xc8\x1b@\xd2U\xef\x8b\xd0tR\x86\x10\x86\xe0t" +
	"\xee\xd736!l\x82\x13e\xb66\xfa\x1e\xae\xfb~" +
	"\xb2\x91e\xe9\xd8\x938\xb9\xde\xc9\x1f\xf3\xbd\x9b\x86E" +
	"\xbe?\xf4\xfd\x9b\xaa\xbe?V\x9d\xcd\x8b4\xdbd\x1b" +
	"\\2\xe4\xcc~\x84@\xc5\xd9\xae\xcf\xb3M\xd6 \xac" +
	"\x81C\x9fnu6\x8br\x07\xb3\xd5\x19\xf6\xd6|\xd6" +
	"\xbf\xe8\xcbtt\xc6\x93E\x9e\xad\xf8\x1d\x12B\x8e\x1d" +
	"\x99K\xa5_\xeduV=\xbb{/wT\x93Q\xad" +
	"{\xa6(\xb7}\x99\x8e\xbd\xf8\x83=\xa7\xfd\xea\xf3\xdb" +
	"\xbedz\xa0\x87\xa3\xe9\x07+7&\x8d\xaf\xfc\x9f\xdc" +
	"<\xbe6[\x8d5;\xb7\xec\xc5\xf4\xbdE\xc0\xbdm" +
	"\xe8\xce\x8f\xc5\xf4\x03\xc5w\x0d\xdd\xae\xc6F\xaa\xd8D" +
	"\x1f*\xbeo\xe8>\xd6\xcc\x98*3\xd1G\x8a\xe7\x0d" +
	"\xdd\xa7B\x06U`\xa2O\x8e\x02n\xd7\xd0}\xadi" +
	"\x09\xaa\xb4D_\x9d\x06\xdc\x17\x86\xee\x1b\xf9_W:" +
	"\xbd\xedw\xf6ot\xf4Gw\xfd>_*\xb6\xb2\xb2" +
	"\xeb7F\xbd\xff\x06\x00\x00\xff\xff\xd4 \x002"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_da3a0d9284ca402f,
		Nodes: []uint64{
			0x922b57c60c6a46d1,
			0xa4b9c59286b69600,
			0xcb5ff253617678e0,
		},
		Compressed: true,
	})
}
