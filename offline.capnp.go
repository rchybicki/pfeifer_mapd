// Code generated by capnpc-go. DO NOT EDIT.

package main

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
)

type Way capnp.Struct

// Way_TypeID is the unique identifier for the type Way.
const Way_TypeID = 0xa4b9c59286b69600

func NewWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 104, PointerCount: 4})
	return Way(st), err
}

func NewRootWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 104, PointerCount: 4})
	return Way(st), err
}

func ReadRootWay(msg *capnp.Message) (Way, error) {
	root, err := msg.Root()
	return Way(root.Struct()), err
}

func (s Way) String() string {
	str, _ := text.Marshal(0xa4b9c59286b69600, capnp.Struct(s))
	return str
}

func (s Way) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Way) DecodeFromPtr(p capnp.Ptr) Way {
	return Way(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Way) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Way) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Way) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Way) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Way) Id() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Way) SetId(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Way) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Way) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Way) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Way) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Way) Ref() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Way) HasRef() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Way) RefBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Way) SetRef(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Way) MaxSpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Way) SetMaxSpeed(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Way) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Way) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Way) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Way) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Way) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Way) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Way) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(40))
}

func (s Way) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(40, math.Float64bits(v))
}

func (s Way) Nodes() (Coordinates_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Coordinates_List(p.List()), err
}

func (s Way) HasNodes() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Way) SetNodes(v Coordinates_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewNodes sets the nodes field to a newly
// allocated Coordinates_List, preferring placement in s's segment.
func (s Way) NewNodes(n int32) (Coordinates_List, error) {
	l, err := NewCoordinates_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Coordinates_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Way) Lanes() uint8 {
	return capnp.Struct(s).Uint8(48)
}

func (s Way) SetLanes(v uint8) {
	capnp.Struct(s).SetUint8(48, v)
}

func (s Way) AdvisorySpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(56))
}

func (s Way) SetAdvisorySpeed(v float64) {
	capnp.Struct(s).SetUint64(56, math.Float64bits(v))
}

func (s Way) Hazard() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Way) HasHazard() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Way) HazardBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Way) SetHazard(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Way) OneWay() bool {
	return capnp.Struct(s).Bit(392)
}

func (s Way) SetOneWay(v bool) {
	capnp.Struct(s).SetBit(392, v)
}

func (s Way) MaxSpeedForward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(64))
}

func (s Way) SetMaxSpeedForward(v float64) {
	capnp.Struct(s).SetUint64(64, math.Float64bits(v))
}

func (s Way) MaxSpeedBackward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(72))
}

func (s Way) SetMaxSpeedBackward(v float64) {
	capnp.Struct(s).SetUint64(72, math.Float64bits(v))
}

func (s Way) MaxSpeedPractical() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(80))
}

func (s Way) SetMaxSpeedPractical(v float64) {
	capnp.Struct(s).SetUint64(80, math.Float64bits(v))
}

func (s Way) MaxSpeedPracticalForward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(88))
}

func (s Way) SetMaxSpeedPracticalForward(v float64) {
	capnp.Struct(s).SetUint64(88, math.Float64bits(v))
}

func (s Way) MaxSpeedPracticalBackward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(96))
}

func (s Way) SetMaxSpeedPracticalBackward(v float64) {
	capnp.Struct(s).SetUint64(96, math.Float64bits(v))
}

// Way_List is a list of Way.
type Way_List = capnp.StructList[Way]

// NewWay creates a new list of Way.
func NewWay_List(s *capnp.Segment, sz int32) (Way_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 104, PointerCount: 4}, sz)
	return capnp.StructList[Way](l), err
}

// Way_Future is a wrapper for a Way promised by a client call.
type Way_Future struct{ *capnp.Future }

func (f Way_Future) Struct() (Way, error) {
	p, err := f.Future.Ptr()
	return Way(p.Struct()), err
}

type Coordinates capnp.Struct

// Coordinates_TypeID is the unique identifier for the type Coordinates.
const Coordinates_TypeID = 0x922b57c60c6a46d1

func NewCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func NewRootCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func ReadRootCoordinates(msg *capnp.Message) (Coordinates, error) {
	root, err := msg.Root()
	return Coordinates(root.Struct()), err
}

func (s Coordinates) String() string {
	str, _ := text.Marshal(0x922b57c60c6a46d1, capnp.Struct(s))
	return str
}

func (s Coordinates) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Coordinates) DecodeFromPtr(p capnp.Ptr) Coordinates {
	return Coordinates(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Coordinates) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Coordinates) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Coordinates) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Coordinates) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Coordinates) Latitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Coordinates) SetLatitude(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Coordinates) Longitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Coordinates) SetLongitude(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Coordinates_List is a list of Coordinates.
type Coordinates_List = capnp.StructList[Coordinates]

// NewCoordinates creates a new list of Coordinates.
func NewCoordinates_List(s *capnp.Segment, sz int32) (Coordinates_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Coordinates](l), err
}

// Coordinates_Future is a wrapper for a Coordinates promised by a client call.
type Coordinates_Future struct{ *capnp.Future }

func (f Coordinates_Future) Struct() (Coordinates, error) {
	p, err := f.Future.Ptr()
	return Coordinates(p.Struct()), err
}

type Offline capnp.Struct

// Offline_TypeID is the unique identifier for the type Offline.
const Offline_TypeID = 0xcb5ff253617678e0

func NewOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func NewRootOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func ReadRootOffline(msg *capnp.Message) (Offline, error) {
	root, err := msg.Root()
	return Offline(root.Struct()), err
}

func (s Offline) String() string {
	str, _ := text.Marshal(0xcb5ff253617678e0, capnp.Struct(s))
	return str
}

func (s Offline) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Offline) DecodeFromPtr(p capnp.Ptr) Offline {
	return Offline(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Offline) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Offline) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Offline) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Offline) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Offline) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Offline) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Offline) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Offline) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Offline) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Offline) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Offline) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Offline) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Offline) Ways() (Way_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Way_List(p.List()), err
}

func (s Offline) HasWays() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Offline) SetWays(v Way_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewWays sets the ways field to a newly
// allocated Way_List, preferring placement in s's segment.
func (s Offline) NewWays(n int32) (Way_List, error) {
	l, err := NewWay_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Way_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Offline) Overlap() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Offline) SetOverlap(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

// Offline_List is a list of Offline.
type Offline_List = capnp.StructList[Offline]

// NewOffline creates a new list of Offline.
func NewOffline_List(s *capnp.Segment, sz int32) (Offline_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1}, sz)
	return capnp.StructList[Offline](l), err
}

// Offline_Future is a wrapper for a Offline promised by a client call.
type Offline_Future struct{ *capnp.Future }

func (f Offline_Future) Struct() (Offline, error) {
	p, err := f.Future.Ptr()
	return Offline(p.Struct()), err
}

const schema_da3a0d9284ca402f = "x\xda\xa4\xd4Mh\x1ce\x18\x07\xf0\xff\xffyg6" +
	"\x9b\xecG2\xbcs\x10\xa9D\xa5BZ\xad&\x1aA" +
	"\x82\xd2P\xa1h\x09\x98\xc9 \xf1 \xc8KfbW" +
	"73a\xb2&\x1b/\x82\x88\xa8\xe0\xc1EDA\xa1" +
	"B\x04\x05O\x1eD\x0f\x82\x07\xf5PO\xf6\xe8\xc9\x83" +
	"\x07\x05\x0bVZ\xecA]y\xa6\xdd\x8f\xe0\xc7\xa5\xb7" +
	"y\x7f\xcf\xb3\xef\xf3\xb2\xef\xfc\xe7VY\xf6\x16\x1a\xb9" +
	"@\xa2#~\xa5\xff\xdd\xe9g\xea\xdf\xac\xdf\xd9C\xd4" +
	"\xa4\xf4\xefY>\xffR\xaf\xb1\xf4=\xbc\x09\xc0\xde\xc2" +
	"\x0b\xf6\x18\xf5\xe9\x0e\xee\x81\x7f\xbd\xf5\xe9\xcb\xbd\xaf?" +
	"?\x88\x9al\x8c:\xfd\xb2\xf5U\xf6\xec\x1b\xdaz\xdf" +
	"\xeb\xfc\xdd\x80\xfd\x1f\xba\xbb.\xfe\xed\xa9ou_\x7f" +
	"\xac\xbb\xdc\xee\xa2\xff\x89\xbd\xe2k\xf7%\x7f\x9d8\xd1" +
	"\xcf77\xdb\xad,\xbd[6\xdcv\xb6\xbd\xf4p\x9e" +
	"\x17I+s\x9d\x94;\xabdT5\x1e\xe0\x11\x08\x8e" +
	"\x9d\x01\xa29\xc3hQ\x18\x90!\x15\x17\xd6\x80h\xde" +
	"0zP\xd8o\xbbN\xab\xf3\\\x92\x02`\x0d\xc2\x1a" +
	"\xd8o\xe7\xd9\xd3\x8a`:\xb4\xc1H^\x1b\xb9\xee\xb8" +
	"\xaf\xa3\x1e\x19\x8c\xb2?\xf3f \xfe\x91\x86\xf1\xaf\x14" +
	"^\x1ff/\xf28\x10\xff\xa4|\x99\xc2@\x18R\x00" +
	"{\x89\xb7\x03\xf1/\xeaW\xd5\x0dC\x1a\xc0^\xe1\x19" +
	" \xbeL\xc35\x11\x06\x9e\x84\xf4\x00\xfb'\x97\x80\xf8" +
	"\xaa\xb6{\xea\xbe\x09\xe9\x03\x96\xa2\xfe\x87zU\xbd\xe2" +
	"\x85\xac\x00\xd6W_\x13\xc3\xb8\xae<\xe1\x87\xe5?9" +
	"Y\xb6{\xea3\xeaU\x09Y\x05lC\xee\x05\xe2\xaa" +
	"\xfaQ\xf5\xc9\xf9\x90\x93\x80\xbd\xad\xf4#\xeas\xeaS" +
	"\x13!\xa7\xf4\x82\xa5\x00\xe2\xa3\xea\xf3\xea5\x13\xb2\x06" +
	"\xd8\x13\xe5\xfes\xea\x8b\"\\\xa8\xbf\xc2\x90u\xc0." +
	"\x94\x85\xbb\xb4\xf0\x80\xfe\xa0Q\x0d\xd9\x00\xec\xfd\xf2\"" +
	"\x10/\xaa/\xab7'C6\x01\xfb\x90\xbc\x06\xc4\xcb" +
	"\xea+\xea\xd3S!\xa7\x01\xfb\xa8\xf4\x80xE\xfd\x09" +
	"\xf5\x99Z\xc8\x19\xc0>.\xe7\x81\xf8I\xf5\xb3\xeaA" +
	"=d\x00\xd8T.\x00q[\xbd+B\xd3J\xe8C" +
	"\xe8\x83\xd3\x99\xdbJY\x87\xb0\x0eN\x14\xe9\xe6\xe0\xb9" +
	"\xbf\xe5\xba\xf1v\x9a&c\xaf\xc4\xc9\xadV\xb6\xe2:" +
	"\x87\x96y6Z\xba\xee\xa1\xaa\xeb\x8eUg\xb3<I" +
	"w\xd8\x04W\x0d93\x8a\x10\xa88\xdbvY\xba\xc3" +
	"\x0a\x84\x15\xb0\xef\x92\xdd\xd6N^\xecc\xb6<\xc3p" +
	"\xcf\xb3\xeeyW$\x833\x9e\xcc\xb3t\xdd\xed\x93\x10" +
	"r\xec\xc8<\x9d\x17{\xaeHF\xef\xf2\xb0r\xcam" +
	"<[\x96\xfe\xa5\xb6Z\xb8\x8dNk\xc3\xb1\xfd\x8f\x9a" +
	"\x0cj\xed\xc1\xd6\xf8\x9f\x9e\xebC\x98\xfcWn\x1e\xdb" +
	"\x9c-\xd7\x9a\x9d\x9b\x861}g\x09\x88\xde4\x8c\xce" +
	"\x8d\xc5\xf4=\xc5\xb7\x0d\xa3\x03\x8d\x8d\x94\xb1\x09\xdeW" +
	"|\xd70\xfaP3c\xca\xcc\x04\x1f(\x9e3\x8c>" +
	"\x16\xd2+\x03\x13|t\x1c\x88\x0e\x0c\xa3/5-^" +
	"\x99\x96\xe0\x8bS@\xf4\x99a\xf4\x95\xdc\xd0\x95N\xef" +
	"\xb9\xfd\xd1\x8d\x0e>t\xd7\xee\xf3\x85|7-\xdan" +
	"{\xd0\xfbw\x00\x00\x00\xff\xffG\xab\xff\xcf"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_da3a0d9284ca402f,
		Nodes: []uint64{
			0x922b57c60c6a46d1,
			0xa4b9c59286b69600,
			0xcb5ff253617678e0,
		},
		Compressed: true,
	})
}
